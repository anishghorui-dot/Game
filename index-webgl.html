<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Runner WebGL - High Performance by ANISH</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            max-width: 900px;
            max-height: 600px;
            width: 100vw;
            height: 100vh;
            border: 4px solid #00ff00;
            box-shadow: 0 0 20px #00ff00;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            pointer-events: none;
            line-height: 1.5;
        }

        #credits {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 14px;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            pointer-events: none;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #00ff00;
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 48px;
            text-shadow: 0 0 20px #00ff00;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #00ff00; }
            50% { text-shadow: 0 0 40px #00ff00, 0 0 60px #00ff00; }
        }

        button {
            padding: 12px 40px;
            font-size: 20px;
            background: #000;
            border: 3px solid #00ff00;
            color: #00ff00;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            margin: 10px;
        }

        button:hover, button:active {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 30px #00ff00;
        }

        .hidden {
            display: none !important;
        }

        /* Touch Controls */
        #touchControls {
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        @media (max-width: 768px), (pointer: coarse) {
            #touchControls {
                display: block;
            }
            h1 {
                font-size: 32px;
            }
            button {
                font-size: 18px;
                padding: 10px 30px;
            }
        }

        .joystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 90px;
            height: 90px;
            background: rgba(0, 255, 0, 0.15);
            border: 2px solid #00ff00;
            border-radius: 50%;
            pointer-events: all;
        }

        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 35px;
            height: 35px;
            background: rgba(0, 255, 0, 0.5);
            border: 2px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.05s;
        }

        .touch-button {
            position: absolute;
            width: 55px;
            height: 55px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            border-radius: 50%;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
        }

        .touch-button:active {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(0.95);
        }

        #jumpBtn { bottom: 120px; right: 50px; }
        #shootBtn { bottom: 30px; right: 50px; }
        #dashBtn { bottom: 30px; right: 120px; }
        #specialBtn { bottom: 120px; right: 120px; font-size: 16px; }

        @media (orientation: landscape) and (max-width: 1024px) {
            #gameContainer {
                border: none;
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="glCanvas" width="900" height="600"></canvas>
        
        <div id="ui">
            <div>üí∞ SCORE: <span id="scoreDisplay">0</span></div>
            <div>‚ù§Ô∏è HP: <span id="healthDisplay">100</span></div>
            <div>‚ö° COMBO: <span id="comboDisplay">0</span></div>
            <div>üìä FPS: <span id="fpsDisplay">60</span></div>
        </div>

        <div id="credits">WebGL by ANISH üöÄ</div>

        <div id="startScreen">
            <h1>üéÆ NEON RUNNER üéÆ</h1>
            <p style="font-size: 20px; margin: 15px; color: #00ffff;">‚ö° WebGL Powered - Buttery Smooth! ‚ö°</p>
            <p style="font-size: 16px; margin: 10px;">All Features: 10 Power-ups, 4 Enemy Types</p>
            <p style="font-size: 16px; margin: 10px;">Collect A-N-I-S-H for 500 Bonus!</p>
            <p style="font-size: 18px; color: #ffff00; margin: 15px;">Created by ANISH</p>
            <button id="startBtn">‚ñ∂ START GAME</button>
            <p style="font-size: 14px; margin-top: 20px; color: #888;">WASD/Arrows: Move | Space: Shoot | Q: Special</p>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h1>GAME OVER</h1>
            <p id="finalScore" style="font-size: 28px; margin: 20px;"></p>
            <p id="collectedLetters" style="font-size: 18px; margin: 10px;"></p>
            <button id="restartBtn">üîÑ RESTART</button>
        </div>

        <div id="touchControls">
            <div class="joystick" id="joystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
            <button class="touch-button" id="jumpBtn">‚Üë</button>
            <button class="touch-button" id="shootBtn">üî´</button>
            <button class="touch-button" id="dashBtn">‚ö°</button>
            <button class="touch-button" id="specialBtn">Q</button>
        </div>
    </div>

    <script>
        // WebGL Setup
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            antialias: false,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        }) || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported on this device!');
            throw new Error('WebGL not available');
        }

        // Vertex shader source
        const vertexShaderSource = `
            attribute vec2 a_position;
            uniform vec2 u_resolution;
            uniform vec2 u_translation;
            uniform vec2 u_scale;
            
            void main() {
                vec2 position = (a_position * u_scale + u_translation) / u_resolution * 2.0 - 1.0;
                gl_Position = vec4(position * vec2(1, -1), 0, 1);
            }
        `;

        // Fragment shader source
        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            
            void main() {
                gl_FragColor = u_color;
            }
        `;

        // Compile shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create and link program
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Get locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const translationLocation = gl.getUniformLocation(program, 'u_translation');
        const scaleLocation = gl.getUniformLocation(program, 'u_scale');
        const colorLocation = gl.getUniformLocation(program, 'u_color');

        // Create position buffer (unit square)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Enable blending for transparency
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Set resolution
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Draw rectangle function
        function drawRect(x, y, width, height, r, g, b, a = 1.0) {
            gl.uniform2f(translationLocation, x, y);
            gl.uniform2f(scaleLocation, width, height);
            gl.uniform4f(colorLocation, r, g, b, a);
            
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Audio setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'shoot':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'hit':
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'collect':
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'powerup':
                    oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }

        // Game state
        let gameRunning = false;
        let score = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        let fpsFrames = 0;
        let fpsTime = 0;

        // Player
        const player = {
            x: 100, y: 400,
            width: 30, height: 40,
            vx: 0, vy: 0,
            speed: 6,
            jumpPower: 14,
            health: 100,
            maxHealth: 100,
            onGround: false,
            facing: 1,
            shootCooldown: 0,
            dashCooldown: 0,
            specialCooldown: 0,
            invincible: 0,
            shield: 0,
            rapidFire: 0,
            flying: 0,
            invisible: 0,
            oneShotActive: 0,
            laserActive: 0,
            doublePoints: 0,
            speedBoost: 0
        };

        // Arrays
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let floatingLetters = [];
        let enemyBullets = [];
        let lasers = [];

        // ANISH letters
        const anishLetters = ['A', 'N', 'I', 'S', 'H'];
        let collectedLetters = [];
        
        // Combo system
        let combo = 0;
        let comboTimer = 0;

        // Platforms
        const platforms = [
            { x: 0, y: 550, width: 900, height: 50 },
            { x: 200, y: 450, width: 150, height: 20 },
            { x: 500, y: 400, width: 150, height: 20 },
            { x: 300, y: 300, width: 120, height: 20 }
        ];

        // Input
        const keys = {};
        const touchInput = { left: false, right: false, up: false, jump: false, shoot: false, dash: false, special: false };

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (gameRunning) {
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
                if (e.key.toLowerCase() === 'w' || e.key === 'ArrowUp') {
                    jump();
                }
                if (e.key.toLowerCase() === 'q') {
                    specialAttack();
                }
                if (e.key.toLowerCase() === 'e' || e.key === 'Shift') {
                    dash();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Touch controls
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        });

        document.addEventListener('touchmove', (e) => {
            if (joystickActive) {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - joystickCenter.x;
                const dy = touch.clientY - joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 30;
                
                if (distance > maxDistance) {
                    joystickKnob.style.left = `50%`;
                    joystickKnob.style.top = `50%`;
                    joystickKnob.style.transform = `translate(calc(-50% + ${(dx / distance) * maxDistance}px), calc(-50% + ${(dy / distance) * maxDistance}px))`;
                } else {
                    joystickKnob.style.left = `50%`;
                    joystickKnob.style.top = `50%`;
                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                }
                
                touchInput.left = dx < -10;
                touchInput.right = dx > 10;
                touchInput.up = dy < -10;
            }
        });

        document.addEventListener('touchend', (e) => {
            if (joystickActive) {
                joystickActive = false;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                touchInput.left = false;
                touchInput.right = false;
                touchInput.up = false;
            }
        });

        // Touch buttons
        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) jump();
        });

        document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) shoot();
        });

        document.getElementById('dashBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) dash();
        });

        document.getElementById('specialBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) specialAttack();
        });

        // Game functions
        function jump() {
            if (player.onGround || player.flying > 0) {
                player.vy = -player.jumpPower;
                player.onGround = false;
            }
        }

        function shoot() {
            if (player.shootCooldown > 0) return;
            
            const damage = player.oneShotActive > 0 ? 999 : 1;
            const cooldown = player.rapidFire > 0 ? 5 : 15;
            
            // Horizontal shot
            bullets.push({
                x: player.x + (player.facing > 0 ? player.width : 0),
                y: player.y + player.height / 2 - 2,
                vx: 12 * player.facing,
                vy: 0,
                width: 12,
                height: 4,
                damage: damage
            });
            
            // Vertical shot
            bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                vx: 0,
                vy: -12,
                width: 4,
                height: 12,
                damage: damage
            });
            
            player.shootCooldown = cooldown;
            playSound('shoot');
        }

        function specialAttack() {
            if (player.specialCooldown > 0) return;
            
            // 360-degree wave
            for (let i = 0; i < 16; i++) {
                const angle = (Math.PI * 2 / 16) * i;
                bullets.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: Math.cos(angle) * 10,
                    vy: Math.sin(angle) * 10,
                    width: 8,
                    height: 8,
                    damage: 1,
                    special: true
                });
            }
            
            player.specialCooldown = 180;
            playSound('powerup');
        }

        function dash() {
            if (player.dashCooldown > 0) return;
            player.vx = player.facing * 20;
            player.dashCooldown = 60;
            player.invincible = 15;
        }

        function spawnEnemy() {
            const types = ['normal', 'tank', 'speeder', 'flying', 'bomber'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let enemy = {
                x: canvas.width + 50,
                y: 450,
                type: type,
                animFrame: 0,
                shootCooldown: 0
            };
            
            switch(type) {
                case 'tank':
                    enemy.width = 60;
                    enemy.height = 50;
                    enemy.health = 5;
                    enemy.vx = -2;
                    enemy.color = { r: 1, g: 0, b: 0 };
                    break;
                case 'speeder':
                    enemy.width = 40;
                    enemy.height = 30;
                    enemy.health = 1;
                    enemy.vx = -7;
                    enemy.color = { r: 1, g: 1, b: 0 };
                    break;
                case 'flying':
                    enemy.width = 35;
                    enemy.height = 35;
                    enemy.health = 2;
                    enemy.vx = -3;
                    enemy.y = 200 + Math.random() * 200;
                    enemy.color = { r: 1, g: 0, b: 1 };
                    break;
                case 'bomber':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.health = 3;
                    enemy.vx = -2;
                    enemy.y = 150;
                    enemy.color = { r: 1, g: 0.5, b: 0 };
                    break;
                default:
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.health = 2;
                    enemy.vx = -4;
                    enemy.color = { r: 1, g: 0, b: 0 };
            }
            
            enemies.push(enemy);
        }

        function spawnPowerup(x, y) {
            if (Math.random() > 0.3) return;
            
            const types = ['health', 'bighealth', 'flying', 'invisible', 'shield', 'rapidfire', 'oneshot', 'laser', 'doublepoints', 'score'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerups.push({
                x: x,
                y: y - 50,
                width: 25,
                height: 25,
                type: type,
                vy: 2,
                timer: 300,
                onGround: false
            });
        }

        function spawnLetter() {
            if (collectedLetters.length >= 5) return;
            if (Math.random() > 0.02) return;
            
            const availableLetters = anishLetters.filter(letter => !collectedLetters.includes(letter));
            if (availableLetters.length === 0) return;
            
            const letter = availableLetters[Math.floor(Math.random() * availableLetters.length)];
            floatingLetters.push({
                letter: letter,
                x: canvas.width + 50,
                y: 200 + Math.random() * 200,
                width: 30,
                height: 30,
                vx: -3
            });
        }

        function createParticles(x, y, r, g, b, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    r: r, g: g, b: b
                });
            }
        }

        function updatePlayer() {
            // Cooldowns
            if (player.shootCooldown > 0) player.shootCooldown--;
            if (player.dashCooldown > 0) player.dashCooldown--;
            if (player.specialCooldown > 0) player.specialCooldown--;
            if (player.invincible > 0) player.invincible--;
            
            // Power-up timers
            if (player.shield > 0) player.shield--;
            if (player.rapidFire > 0) player.rapidFire--;
            if (player.flying > 0) player.flying--;
            if (player.invisible > 0) player.invisible--;
            if (player.oneShotActive > 0) player.oneShotActive--;
            if (player.laserActive > 0) player.laserActive--;
            if (player.doublePoints > 0) player.doublePoints--;
            if (player.speedBoost > 0) player.speedBoost--;
            
            // Movement
            const moveSpeed = player.speedBoost > 0 ? player.speed * 1.5 : player.speed;
            
            if (keys['a'] || keys['arrowleft'] || touchInput.left) {
                player.vx = -moveSpeed;
                player.facing = -1;
            } else if (keys['d'] || keys['arrowright'] || touchInput.right) {
                player.vx = moveSpeed;
                player.facing = 1;
            } else {
                player.vx *= 0.8;
            }
            
            // Gravity
            if (player.flying > 0) {
                if (keys['w'] || keys['arrowup'] || touchInput.up) {
                    player.vy = -player.speed;
                } else if (keys['s'] || keys['arrowdown']) {
                    player.vy = player.speed;
                } else {
                    player.vy *= 0.8;
                }
            } else {
                player.vy += 0.8;
            }
            
            // Apply velocity
            player.x += player.vx;
            player.y += player.vy;
            
            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
            
            // Platform collision
            player.onGround = false;
            platforms.forEach(platform => {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.vy >= 0) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }
            });
            
            // Bottom boundary
            if (player.y > canvas.height) {
                player.health = 0;
            }
            
            // Laser shooting
            if (player.laserActive > 0 && frameCount % 5 === 0) {
                lasers.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    dir: 'horizontal',
                    life: 10
                });
                lasers.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    dir: 'vertical',
                    life: 10
                });
            }
        }

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
                    bullet.y < -50 || bullet.y > canvas.height + 50) {
                    return false;
                }
                
                // Check enemy collision
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        enemy.health -= bullet.damage;
                        createParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 
                                      enemy.color.r, enemy.color.g, enemy.color.b, 8);
                        
                        if (enemy.health <= 0) {
                            const points = (enemy.type === 'tank' ? 50 : 
                                          enemy.type === 'bomber' ? 40 : 
                                          enemy.type === 'speeder' ? 30 : 20);
                            score += points * (player.doublePoints > 0 ? 2 : 1);
                            combo++;
                            comboTimer = 120;
                            
                            enemies.splice(i, 1);
                            spawnPowerup(enemy.x, enemy.y);
                            playSound('hit');
                        }
                        
                        return false;
                    }
                }
                
                return true;
            });
        }

        function updateLasers() {
            lasers = lasers.filter(laser => {
                laser.life--;
                
                // Check enemy collision
                enemies.forEach(enemy => {
                    let hit = false;
                    if (laser.dir === 'horizontal') {
                        hit = Math.abs(laser.y - (enemy.y + enemy.height / 2)) < 5 &&
                              enemy.x < canvas.width && enemy.x > 0;
                    } else {
                        hit = Math.abs(laser.x - (enemy.x + enemy.width / 2)) < 5 &&
                              enemy.y < canvas.height && enemy.y > 0;
                    }
                    
                    if (hit) {
                        enemy.health -= 0.5;
                        if (enemy.health <= 0) {
                            score += 30 * (player.doublePoints > 0 ? 2 : 1);
                        }
                    }
                });
                
                return laser.life > 0;
            });
        }

        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                enemy.x += enemy.vx;
                enemy.animFrame += 0.1;
                
                // Flying enemy movement
                if (enemy.type === 'flying') {
                    enemy.y += Math.sin(enemy.animFrame) * 2;
                }
                
                // Shooting enemies
                if ((enemy.type === 'tank' || enemy.type === 'bomber') && enemy.shootCooldown <= 0) {
                    enemyBullets.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        vx: -6,
                        vy: 0,
                        width: 10,
                        height: 10,
                        bomb: enemy.type === 'bomber'
                    });
                    enemy.shootCooldown = enemy.type === 'bomber' ? 180 : 90;
                }
                if (enemy.shootCooldown > 0) enemy.shootCooldown--;
                
                // Check player collision
                if (!player.invincible && !player.invisible &&
                    player.x + player.width > enemy.x &&
                    player.x < enemy.x + enemy.width &&
                    player.y + player.height > enemy.y &&
                    player.y < enemy.y + enemy.height) {
                    
                    if (player.shield > 0) {
                        player.shield = 0;
                    } else {
                        player.health -= 10;
                        player.invincible = 60;
                    }
                    createParticles(player.x, player.y, 1, 0, 0, 10);
                }
                
                if (enemy.health <= 0 || enemy.x < -100) {
                    return false;
                }
                
                return true;
            });
        }

        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Check player collision
                if (!player.invincible && !player.invisible &&
                    player.x + player.width > bullet.x &&
                    player.x < bullet.x + bullet.width &&
                    player.y + player.height > bullet.y &&
                    player.y < bullet.y + bullet.height) {
                    
                    if (player.shield > 0) {
                        player.shield = 0;
                    } else {
                        player.health -= bullet.bomb ? 20 : 10;
                        player.invincible = 60;
                    }
                    return false;
                }
                
                return bullet.x > -50 && bullet.x < canvas.width + 50;
            });
        }

        function updatePowerups() {
            powerups = powerups.filter(powerup => {
                if (!powerup.onGround) {
                    powerup.y += powerup.vy;
                    
                    // Check platform collision
                    platforms.forEach(platform => {
                        if (powerup.x + powerup.width > platform.x &&
                            powerup.x < platform.x + platform.width &&
                            powerup.y + powerup.height > platform.y &&
                            powerup.y + powerup.height < platform.y + platform.height) {
                            powerup.y = platform.y - powerup.height;
                            powerup.onGround = true;
                        }
                    });
                }
                
                if (powerup.onGround) {
                    powerup.timer--;
                    if (powerup.timer <= 0) return false;
                }
                
                // Check player collision
                if (player.x + player.width > powerup.x &&
                    player.x < powerup.x + powerup.width &&
                    player.y + player.height > powerup.y &&
                    player.y < powerup.y + powerup.height) {
                    
                    switch(powerup.type) {
                        case 'health':
                            player.health = Math.min(player.health + 20, player.maxHealth);
                            break;
                        case 'bighealth':
                            player.health = player.maxHealth;
                            break;
                        case 'flying':
                            player.flying = 600;
                            break;
                        case 'invisible':
                            player.invisible = 600;
                            break;
                        case 'shield':
                            player.shield = 600;
                            break;
                        case 'rapidfire':
                            player.rapidFire = 600;
                            break;
                        case 'oneshot':
                            player.oneShotActive = 600;
                            break;
                        case 'laser':
                            player.laserActive = 600;
                            break;
                        case 'doublepoints':
                            player.doublePoints = 600;
                            break;
                        case 'score':
                            score += 100;
                            break;
                    }
                    
                    playSound('powerup');
                    createParticles(powerup.x, powerup.y, 0, 1, 1, 15);
                    return false;
                }
                
                return true;
            });
        }

        function updateLetters() {
            floatingLetters = floatingLetters.filter(letter => {
                letter.x += letter.vx;
                
                // Check player collision
                if (player.x + player.width > letter.x &&
                    player.x < letter.x + letter.width &&
                    player.y + player.height > letter.y &&
                    player.y < letter.y + letter.height) {
                    
                    if (!collectedLetters.includes(letter.letter)) {
                        collectedLetters.push(letter.letter);
                        playSound('collect');
                        createParticles(letter.x, letter.y, 1, 1, 0, 20);
                        
                        if (collectedLetters.length === 5) {
                            score += 500;
                            playSound('powerup');
                        }
                    }
                    return false;
                }
                
                return letter.x > -50;
            });
        }

        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                return particle.life > 0;
            });
        }

        function update() {
            if (!gameRunning) return;
            
            frameCount++;
            
            // Update combo timer
            if (comboTimer > 0) {
                comboTimer--;
            } else {
                combo = 0;
            }
            
            updatePlayer();
            updateBullets();
            updateLasers();
            updateEnemies();
            updateEnemyBullets();
            updatePowerups();
            updateLetters();
            updateParticles();
            
            // Spawn enemies
            if (frameCount % 90 === 0) {
                spawnEnemy();
            }
            
            // Spawn letters
            if (frameCount % 10 === 0) {
                spawnLetter();
            }
            
            // Check game over
            if (player.health <= 0) {
                gameOver();
            }
            
            // Update UI
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('healthDisplay').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('comboDisplay').textContent = combo > 0 ? `x${combo}` : '0';
        }

        function draw() {
            // Clear screen
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Draw background grid
            for (let x = 0; x < canvas.width; x += 30) {
                drawRect(x, 0, 1, canvas.height, 0, 0.3, 0.3, 0.3);
            }
            for (let y = 0; y < canvas.height; y += 30) {
                drawRect(0, y, canvas.width, 1, 0, 0.3, 0.3, 0.3);
            }
            
            // Draw platforms
            platforms.forEach(platform => {
                drawRect(platform.x, platform.y, platform.width, platform.height, 0, 1, 0, 1);
            });
            
            // Draw particles
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                drawRect(particle.x, particle.y, 3, 3, particle.r, particle.g, particle.b, alpha);
            });
            
            // Draw lasers
            lasers.forEach(laser => {
                if (laser.dir === 'horizontal') {
                    drawRect(0, laser.y - 2, canvas.width, 4, 0, 1, 1, 0.6);
                } else {
                    drawRect(laser.x - 2, 0, 4, canvas.height, 0, 1, 1, 0.6);
                }
            });
            
            // Draw player
            if (!player.invisible || frameCount % 10 < 5) {
                let playerColor = { r: 0, g: 1, b: 1 };
                if (player.invincible > 0) playerColor = { r: 1, g: 1, b: 0 };
                if (player.flying > 0) playerColor = { r: 1, g: 0, b: 1 };
                
                drawRect(player.x, player.y, player.width, player.height, 
                        playerColor.r, playerColor.g, playerColor.b, 1);
                
                // Shield effect
                if (player.shield > 0) {
                    drawRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10, 
                            0, 1, 1, 0.3);
                }
            }
            
            // Draw bullets
            bullets.forEach(bullet => {
                let color = bullet.special ? { r: 0, g: 1, b: 0 } :
                           bullet.damage >= 999 ? { r: 1, g: 0, b: 0 } :
                           { r: 1, g: 1, b: 0 };
                drawRect(bullet.x, bullet.y, bullet.width, bullet.height, 
                        color.r, color.g, color.b, 1);
            });
            
            // Draw enemy bullets
            enemyBullets.forEach(bullet => {
                drawRect(bullet.x, bullet.y, bullet.width, bullet.height, 1, 0.5, 0, 1);
            });
            
            // Draw enemies
            enemies.forEach(enemy => {
                drawRect(enemy.x, enemy.y, enemy.width, enemy.height, 
                        enemy.color.r, enemy.color.g, enemy.color.b, 1);
            });
            
            // Draw powerups
            powerups.forEach(powerup => {
                const pulse = Math.sin(frameCount * 0.1) * 0.3 + 0.7;
                drawRect(powerup.x, powerup.y, powerup.width, powerup.height, 
                        0, 1, 1, pulse);
            });
            
            // Draw letters
            floatingLetters.forEach(letter => {
                drawRect(letter.x, letter.y, letter.width, letter.height, 1, 1, 0, 1);
            });
        }

        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            
            // Calculate FPS
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            fpsFrames++;
            fpsTime += deltaTime;
            
            if (fpsTime >= 1000) {
                fps = Math.round(fpsFrames / (fpsTime / 1000));
                document.getElementById('fpsDisplay').textContent = fps;
                fpsFrames = 0;
                fpsTime = 0;
            }
            
            update();
            draw();
        }

        function startGame() {
            gameRunning = true;
            score = 0;
            frameCount = 0;
            combo = 0;
            comboTimer = 0;
            collectedLetters = [];
            
            player.x = 100;
            player.y = 400;
            player.vx = 0;
            player.vy = 0;
            player.health = 100;
            player.facing = 1;
            player.shootCooldown = 0;
            player.dashCooldown = 0;
            player.specialCooldown = 0;
            player.invincible = 0;
            player.shield = 0;
            player.rapidFire = 0;
            player.flying = 0;
            player.invisible = 0;
            player.oneShotActive = 0;
            player.laserActive = 0;
            player.doublePoints = 0;
            
            bullets = [];
            enemies = [];
            particles = [];
            powerups = [];
            floatingLetters = [];
            enemyBullets = [];
            lasers = [];
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            // Request fullscreen on mobile
            if ('ontouchstart' in window) {
                canvas.requestFullscreen?.() || 
                canvas.webkitRequestFullscreen?.() || 
                canvas.mozRequestFullScreen?.();
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `FINAL SCORE: ${score}`;
            document.getElementById('collectedLetters').textContent = 
                `Collected Letters: ${collectedLetters.join('-') || 'None'}`;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function restartGame() {
            startGame();
        }

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
